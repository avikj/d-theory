<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway's Orchestra :: AVIK HSV</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            font-family: 'Courier New', monospace;
            color: #00FFFF;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }
        
        #header {
            padding: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
        }
        
        .avik-title {
            font-size: 36px;
            letter-spacing: 10px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .letter-a { color: #FF1493; text-shadow: 0 0 20px #FF1493; }
        .letter-v { color: #FFFF00; text-shadow: 0 0 20px #FFFF00; }
        .letter-i { color: #00FFFF; text-shadow: 0 0 20px #00FFFF; }
        .letter-k { color: #9370DB; text-shadow: 0 0 20px #9370DB; }
        
        .subtitle {
            font-size: 12px;
            color: #00FF00;
            letter-spacing: 3px;
            text-shadow: 0 0 10px #00FF00;
        }
        
        #main-area {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        #life-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #lifeCanvas {
            cursor: crosshair;
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
        }
        
        #waveform-container {
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border-left: 2px solid rgba(0, 255, 255, 0.3);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #waveformCanvas {
            width: 100%;
            height: 200px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        #spectrumCanvas {
            width: 100%;
            height: 200px;
            border: 1px solid rgba(255, 20, 147, 0.3);
        }
        
        #controls {
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border-top: 2px solid rgba(0, 255, 255, 0.3);
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        
        button {
            background: linear-gradient(135deg, rgba(255,20,147,0.3), rgba(147,112,219,0.3));
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.6);
        }
        
        button.active {
            background: linear-gradient(135deg, rgba(255,20,147,0.8), rgba(147,112,219,0.8));
            border-color: #FF1493;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 12px;
            border-radius: 5px;
        }
        
        label {
            font-size: 11px;
            color: #00FFFF;
        }
        
        input[type="range"] {
            width: 100px;
        }
        
        select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        
        #metrics {
            display: flex;
            gap: 20px;
            font-size: 11px;
            color: #00FF00;
        }
        
        .metric {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #FFFF00;
            text-shadow: 0 0 10px #FFFF00;
        }
        
        #harmony-display {
            font-size: 11px;
            color: #9370DB;
            text-align: center;
            margin-top: 10px;
        }
        
        .theory-note {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
            padding: 10px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <div class="avik-title">
                <span class="letter-a">A</span><span class="letter-v">V</span><span class="letter-i">I</span><span class="letter-k">K</span>
            </div>
            <div class="subtitle">CONWAY'S ORCHESTRA :: 1+2â‡’3 | 1Ã—2â‡’4 :: MUSIC OF THE SPHERES</div>
        </div>
        
        <div id="main-area">
            <div id="life-container">
                <canvas id="lifeCanvas"></canvas>
            </div>
            
            <div id="waveform-container">
                <div>
                    <div style="font-size: 12px; margin-bottom: 10px; color: #00FFFF;">WAVEFORM</div>
                    <canvas id="waveformCanvas"></canvas>
                </div>
                
                <div>
                    <div style="font-size: 12px; margin-bottom: 10px; color: #FF1493;">SPECTRUM</div>
                    <canvas id="spectrumCanvas"></canvas>
                </div>
                
                <div id="metrics">
                    <div class="metric">
                        <div class="metric-value" id="population">0</div>
                        <div>Cells</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="generation">0</div>
                        <div>Gen</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="voices">0</div>
                        <div>Voices</div>
                    </div>
                </div>
                
                <div id="harmony-display">
                    <div>HARMONIC RATIO: <span id="ratio">1:1</span></div>
                    <div>TESLA FREQ: <span id="tesla-freq">432</span> Hz</div>
                </div>
                
                <div class="theory-note">
                    1,2 â†’ 3,4 DUALITY<br>
                    Addition: 1+2=3<br>
                    Multiplication: 2Ã—2=4<br>
                    Birth rule: 3 neighbors<br>
                    Stability: 2-3 neighbors<br>
                    Death: &lt;2 or &gt;3
                </div>
            </div>
        </div>
        
        <div id="controls">
            <button id="audioBtn">ðŸ”Š START AUDIO</button>
            <button id="playBtn">â–¶ PLAY</button>
            <button id="stepBtn">STEP</button>
            <button id="clearBtn">CLEAR</button>
            
            <div class="control-group">
                <label>Speed:</label>
                <input type="range" id="speedSlider" min="1" max="30" value="5">
                <span id="speedValue">5</span>
            </div>
            
            <div class="control-group">
                <label>Scale:</label>
                <select id="scaleSelect">
                    <option value="pythagorean">Pythagorean</option>
                    <option value="just">Just Intonation</option>
                    <option value="equal">Equal Temperament</option>
                    <option value="harmonic">Harmonic Series</option>
                    <option value="tesla">Tesla (432Hz)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Pattern:</label>
                <select id="patternSelect">
                    <option value="free">Free Draw</option>
                    <option value="1x2">1Ã—2 Unit</option>
                    <option value="3x4">3Ã—4 Grid</option>
                    <option value="glider">Glider</option>
                    <option value="blinker">Blinker (Period-2)</option>
                    <option value="pulsar">Pulsar</option>
                </select>
            </div>
            
            <button id="randomBtn">RANDOM</button>
        </div>
    </div>
    
    <script>
        // Canvas setup
        const lifeCanvas = document.getElementById('lifeCanvas');
        const lifeCtx = lifeCanvas.getContext('2d');
        const waveCanvas = document.getElementById('waveformCanvas');
        const waveCtx = waveCanvas.getContext('2d');
        const specCanvas = document.getElementById('spectrumCanvas');
        const specCtx = specCanvas.getContext('2d');
        
        const cellSize = 10;
        const cols = 80;
        const rows = 60;
        lifeCanvas.width = cols * cellSize;
        lifeCanvas.height = rows * cellSize;
        waveCanvas.width = 260;
        waveCanvas.height = 200;
        specCanvas.width = 260;
        specCanvas.height = 200;
        
        // Game state
        let grid = createGrid();
        let running = false;
        let generation = 0;
        let speed = 5;
        let lastUpdate = 0;
        let isDrawing = false;
        let selectedPattern = 'free';
        
        // Audio setup
        let audioContext;
        let masterGain;
        let analyser;
        let audioActive = false;
        let cellOscillators = new Map(); // Map of "x,y" to {osc, gain}
        let currentScale = 'pythagorean';
        
        // Musical scales (ratios relative to fundamental)
        const scales = {
            pythagorean: [1, 9/8, 81/64, 4/3, 3/2, 27/16, 243/128, 2], // Pythagorean
            just: [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8, 2], // Just intonation
            equal: [1, 1.122, 1.260, 1.335, 1.498, 1.682, 1.888, 2], // Equal temperament
            harmonic: [1, 2, 3, 4, 5, 6, 7, 8], // Harmonic series
            tesla: [1, 1.125, 1.265, 1.333, 1.5, 1.687, 1.898, 2] // Based on 432Hz
        };
        
        // Patterns
        const patterns = {
            '1x2': [[0,0],[0,1]], // The fundamental unit: 1 column, 2 rows
            '3x4': [ // 3Ã—4 grid representing the expansion
                [0,0],[0,1],[0,2],[0,3],
                [1,0],[1,1],[1,2],[1,3],
                [2,0],[2,1],[2,2],[2,3]
            ],
            glider: [[0,1],[1,2],[2,0],[2,1],[2,2]],
            blinker: [[0,0],[0,1],[0,2]],
            pulsar: [
                [2,0],[3,0],[4,0],[8,0],[9,0],[10,0],
                [0,2],[5,2],[7,2],[12,2],
                [0,3],[5,3],[7,3],[12,3],
                [0,4],[5,4],[7,4],[12,4],
                [2,5],[3,5],[4,5],[8,5],[9,5],[10,5],
                [2,7],[3,7],[4,7],[8,7],[9,7],[10,7],
                [0,8],[5,8],[7,8],[12,8],
                [0,9],[5,9],[7,9],[12,9],
                [0,10],[5,10],[7,10],[12,10],
                [2,12],[3,12],[4,12],[8,12],[9,12],[10,12]
            ]
        };
        
        function createGrid() {
            return Array(rows).fill(null).map(() => Array(cols).fill(0));
        }
        
        function countNeighbors(x, y) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const newX = (x + i + rows) % rows;
                    const newY = (y + j + cols) % cols;
                    count += grid[newX][newY];
                }
            }
            return count;
        }
        
        function updateGrid() {
            const newGrid = createGrid();
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const neighbors = countNeighbors(i, j);
                    const cell = grid[i][j];
                    
                    // Conway's rules - notice the 1,2â†’3,4 pattern
                    // Birth: exactly 3 neighbors (1+2)
                    // Survival: 2 or 3 neighbors
                    // Death: <2 (isolation) or >3 (overcrowding)
                    // The numbers 2,3,4 form the stability boundary
                    
                    if (cell === 1 && (neighbors === 2 || neighbors === 3)) {
                        newGrid[i][j] = 1;
                    } else if (cell === 0 && neighbors === 3) {
                        newGrid[i][j] = 1;
                    }
                }
            }
            
            grid = newGrid;
            generation++;
            updateAudio();
        }
        
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.1;
            
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            
            masterGain.connect(analyser);
            analyser.connect(audioContext.destination);
            
            audioActive = true;
            document.getElementById('audioBtn').classList.add('active');
            document.getElementById('audioBtn').textContent = 'ðŸ”Š AUDIO ON';
        }
        
        function getFrequencyForCell(x, y) {
            // Base frequency using Tesla's 432Hz or traditional 440Hz
            const baseFreq = currentScale === 'tesla' ? 432 : 440;
            
            // Map cell position to scale degree
            const scaleRatios = scales[currentScale];
            const octave = Math.floor(y / scaleRatios.length);
            const degree = y % scaleRatios.length;
            const ratio = scaleRatios[degree];
            
            // Add harmonic variation based on x position
            const harmonicMod = 1 + (x / cols) * 0.5;
            
            return baseFreq * ratio * Math.pow(2, octave - 2) * harmonicMod;
        }
        
        function updateAudio() {
            if (!audioActive) return;
            
            const currentCells = new Set();
            
            // Scan grid for living cells
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (grid[i][j] === 1) {
                        const key = `${i},${j}`;
                        currentCells.add(key);
                        
                        // Create oscillator if it doesn't exist
                        if (!cellOscillators.has(key)) {
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            
                            const neighbors = countNeighbors(i, j);
                            
                            // Waveform based on neighbor count (1,2â†’3,4 pattern)
                            if (neighbors <= 2) {
                                osc.type = 'sine'; // Isolation/stability
                            } else if (neighbors === 3) {
                                osc.type = 'triangle'; // Birth condition
                            } else {
                                osc.type = 'square'; // Overcrowding
                            }
                            
                            osc.frequency.value = getFrequencyForCell(i, j);
                            
                            // Volume based on neighbor count
                            const volume = 0.05 * (neighbors / 8);
                            gain.gain.value = volume;
                            
                            osc.connect(gain);
                            gain.connect(masterGain);
                            osc.start();
                            
                            cellOscillators.set(key, {osc, gain});
                        } else {
                            // Update existing oscillator
                            const {osc, gain} = cellOscillators.get(key);
                            const neighbors = countNeighbors(i, j);
                            const volume = 0.05 * (neighbors / 8);
                            gain.gain.setTargetAtTime(volume, audioContext.currentTime, 0.01);
                        }
                    }
                }
            }
            
            // Remove oscillators for dead cells
            for (const [key, {osc, gain}] of cellOscillators.entries()) {
                if (!currentCells.has(key)) {
                    gain.gain.setTargetAtTime(0, audioContext.currentTime, 0.01);
                    setTimeout(() => {
                        osc.stop();
                        gain.disconnect();
                        osc.disconnect();
                        cellOscillators.delete(key);
                    }, 100);
                }
            }
            
            // Update metrics
            document.getElementById('voices').textContent = cellOscillators.size;
            
            // Calculate harmonic ratio
            const activeCells = Array.from(currentCells);
            if (activeCells.length >= 2) {
                const [cell1, cell2] = activeCells.slice(0, 2);
                const [r1, c1] = cell1.split(',').map(Number);
                const [r2, c2] = cell2.split(',').map(Number);
                const freq1 = getFrequencyForCell(r1, c1);
                const freq2 = getFrequencyForCell(r2, c2);
                const ratio = (freq2 / freq1).toFixed(3);
                document.getElementById('ratio').textContent = `1:${ratio}`;
            }
        }
        
        function drawGrid() {
            lifeCtx.fillStyle = '#000';
            lifeCtx.fillRect(0, 0, lifeCanvas.width, lifeCanvas.height);
            
            // Draw grid lines
            lifeCtx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            lifeCtx.lineWidth = 1;
            
            for (let i = 0; i <= rows; i++) {
                lifeCtx.beginPath();
                lifeCtx.moveTo(0, i * cellSize);
                lifeCtx.lineTo(cols * cellSize, i * cellSize);
                lifeCtx.stroke();
            }
            
            for (let j = 0; j <= cols; j++) {
                lifeCtx.beginPath();
                lifeCtx.moveTo(j * cellSize, 0);
                lifeCtx.lineTo(j * cellSize, rows * cellSize);
                lifeCtx.stroke();
            }
            
            // Draw cells
            let population = 0;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (grid[i][j] === 1) {
                        population++;
                        const neighbors = countNeighbors(i, j);
                        
                        // Color based on neighbor count (visualizing 1,2â†’3,4 pattern)
                        let color;
                        if (neighbors < 2) {
                            color = '#FF1493'; // Pink - dying (isolation)
                        } else if (neighbors === 2) {
                            color = '#00FFFF'; // Cyan - stable
                        } else if (neighbors === 3) {
                            color = '#FFFF00'; // Yellow - birth/stable
                        } else {
                            color = '#9370DB'; // Purple - dying (overcrowding)
                        }
                        
                        lifeCtx.fillStyle = color;
                        lifeCtx.shadowColor = color;
                        lifeCtx.shadowBlur = 8;
                        lifeCtx.fillRect(
                            j * cellSize + 1,
                            i * cellSize + 1,
                            cellSize - 2,
                            cellSize - 2
                        );
                        lifeCtx.shadowBlur = 0;
                    }
                }
            }
            
            document.getElementById('population').textContent = population;
            document.getElementById('generation').textContent = generation;
        }
        
        function drawWaveform() {
            if (!analyser) return;
            
            const bufferLength = analyser.fftSize;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            waveCtx.fillStyle = '#000';
            waveCtx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);
            
            waveCtx.strokeStyle = '#00FFFF';
            waveCtx.lineWidth = 2;
            waveCtx.shadowColor = '#00FFFF';
            waveCtx.shadowBlur = 5;
            waveCtx.beginPath();
            
            const sliceWidth = waveCanvas.width / bufferLength;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * waveCanvas.height / 2;
                
                if (i === 0) {
                    waveCtx.moveTo(x, y);
                } else {
                    waveCtx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            waveCtx.stroke();
            waveCtx.shadowBlur = 0;
        }
        
        function drawSpectrum() {
            if (!analyser) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            specCtx.fillStyle = '#000';
            specCtx.fillRect(0, 0, specCanvas.width, specCanvas.height);
            
            const barWidth = (specCanvas.width / bufferLength) * 2.5;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * specCanvas.height;
                
                // Color gradient based on frequency
                const hue = (i / bufferLength) * 300;
                specCtx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                specCtx.fillRect(x, specCanvas.height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
            
            // Update Tesla frequency display
            const avgFreq = dataArray.reduce((a, b) => a + b) / dataArray.length;
            document.getElementById('tesla-freq').textContent = Math.floor(avgFreq * 2);
        }
        
        function placePattern(row, col, pattern) {
            if (pattern === 'free') return;
            
            const cells = patterns[pattern];
            cells.forEach(([r, c]) => {
                const newRow = (row + r) % rows;
                const newCol = (col + c) % cols;
                grid[newRow][newCol] = 1;
            });
        }
        
        function toggleCell(x, y) {
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                if (selectedPattern === 'free') {
                    grid[row][col] = 1;
                } else {
                    placePattern(row, col, selectedPattern);
                }
            }
        }
        
        // Event listeners
        lifeCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = lifeCanvas.getBoundingClientRect();
            toggleCell(e.clientX - rect.left, e.clientY - rect.top);
            drawGrid();
            updateAudio();
        });
        
        lifeCanvas.addEventListener('mousemove', (e) => {
            if (isDrawing && selectedPattern === 'free') {
                const rect = lifeCanvas.getBoundingClientRect();
                toggleCell(e.clientX - rect.left, e.clientY - rect.top);
                drawGrid();
                updateAudio();
            }
        });
        
        lifeCanvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });
        
        document.getElementById('audioBtn').addEventListener('click', () => {
            if (!audioActive) {
                initAudio();
            }
        });
        
        document.getElementById('playBtn').addEventListener('click', (e) => {
            running = !running;
            e.target.textContent = running ? 'â¸ PAUSE' : 'â–¶ PLAY';
            e.target.classList.toggle('active');
        });
        
        document.getElementById('stepBtn').addEventListener('click', () => {
            updateGrid();
            drawGrid();
        });
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            grid = createGrid();
            generation = 0;
            cellOscillators.forEach(({osc, gain}) => {
                osc.stop();
                gain.disconnect();
                osc.disconnect();
            });
            cellOscillators.clear();
            drawGrid();
        });
        
        document.getElementById('randomBtn').addEventListener('click', () => {
            grid = createGrid();
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    grid[i][j] = Math.random() > 0.8 ? 1 : 0;
                }
            }
            generation = 0;
            drawGrid();
            updateAudio();
        });
        
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = speed;
        });
        
        document.getElementById('scaleSelect').addEventListener('change', (e) => {
            currentScale = e.target.value;
            // Rebuild audio with new scale
            cellOscillators.forEach(({osc, gain}) => {
                osc.stop();
                gain.disconnect();
                osc.disconnect();
            });
            cellOscillators.clear();
            updateAudio();
        });
        
        document.getElementById('patternSelect').addEventListener('change', (e) => {
            selectedPattern = e.target.value;
        });
        
        // Animation loop
        function animate(timestamp) {
            requestAnimationFrame(animate);
            
            const interval = 1000 / speed;
            
            if (running && timestamp - lastUpdate >= interval) {
                updateGrid();
                drawGrid();
                lastUpdate = timestamp;
            }
            
            drawWaveform();
            drawSpectrum();
        }
        
        // Initial setup
        drawGrid();
        animate(0);
        
        // Place initial 1Ã—2 pattern in center
        const centerX = Math.floor(rows / 2);
        const centerY = Math.floor(cols / 2);
        placePattern(centerX, centerY, '1x2');
        drawGrid();
    </script>
</body>
</html>