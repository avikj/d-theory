<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HYPERACTIV :: SYNTHETIC SYNESTHESIA</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body { 
            background: #000; 
            cursor: crosshair;
            font-family: 'Courier New', monospace;
        }
        canvas { display: block; }
        
        #overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00FFFF;
            z-index: 100;
            font-size: 14px;
            text-shadow: 0 0 10px #00FFFF;
            pointer-events: none;
        }
        
        .neon-text {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #avik-signature {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 5px;
            z-index: 100;
        }
        
        .letter-a { color: #FF1493; text-shadow: 0 0 20px #FF1493; }
        .letter-v { color: #FFFF00; text-shadow: 0 0 20px #FFFF00; }
        .letter-i { color: #00FFFF; text-shadow: 0 0 20px #00FFFF; }
        .letter-k { color: #9370DB; text-shadow: 0 0 20px #9370DB; }
    </style>
</head>
<body>
    <div id="overlay">
        <div class="neon-text">SCROLL :: ROTATE</div>
        <div class="neon-text">CLICK :: EXPLODE</div>
        <div class="neon-text">SPACE :: MORPH</div>
    </div>
    
    <div id="avik-signature">
        <span class="letter-a">A</span><span class="letter-v">V</span><span class="letter-i">I</span><span class="letter-k">K</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // HYPERACTIV COLOR PALETTE
        const COLORS = {
            pink: 0xFF1493,
            yellow: 0xFFFF00,
            cyan: 0x00FFFF,
            purple: 0x9370DB,
            magenta: 0xFF00FF,
            green: 0x00FF00,
            orange: 0xFFA500,
            red: 0xFF0000
        };
        
        // LETTER TO COLOR MAPPING
        const letterColors = {
            'h': COLORS.pink,
            'y': COLORS.yellow,
            'p': COLORS.pink,
            'e': COLORS.green,
            'r': COLORS.red,
            'a': COLORS.pink,
            'c': COLORS.cyan,
            't': COLORS.green,
            'i': COLORS.cyan,
            'v': COLORS.yellow
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 1, 100);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);
        
        const pointLight1 = new THREE.PointLight(COLORS.cyan, 2, 50);
        pointLight1.position.set(20, 20, 20);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(COLORS.magenta, 2, 50);
        pointLight2.position.set(-20, -20, 20);
        scene.add(pointLight2);
        
        // CENTRAL TETRAHEDRAL CRYSTAL
        const tetraGeometry = new THREE.TetrahedronGeometry(5, 0);
        const tetraMaterial = new THREE.MeshPhongMaterial({
            color: COLORS.cyan,
            wireframe: true,
            emissive: COLORS.cyan,
            emissiveIntensity: 0.5
        });
        const tetrahedron = new THREE.Mesh(tetraGeometry, tetraMaterial);
        scene.add(tetrahedron);
        
        // Inner glowing core
        const coreGeometry = new THREE.SphereGeometry(2, 16, 16);
        const coreMaterial = new THREE.MeshBasicMaterial({
            color: COLORS.magenta,
            transparent: true,
            opacity: 0.8
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        tetrahedron.add(core);
        
        // DNA HELIX
        const helixGroup = new THREE.Group();
        const helixPoints = [];
        const steps = 100;
        
        for (let i = 0; i < steps; i++) {
            const t = i / steps * Math.PI * 4;
            const x = Math.cos(t) * 10;
            const y = (i - steps/2) * 0.5;
            const z = Math.sin(t) * 10;
            helixPoints.push(new THREE.Vector3(x, y, z));
            
            // Create spheres for DNA bases
            if (i % 5 === 0) {
                const baseGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const baseMaterial = new THREE.MeshPhongMaterial({
                    color: Object.values(COLORS)[i % 8],
                    emissive: Object.values(COLORS)[i % 8],
                    emissiveIntensity: 0.5
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(x, y, z);
                helixGroup.add(base);
                
                // Connecting bars
                const barGeometry = new THREE.CylinderGeometry(0.1, 0.1, 20);
                const barMaterial = new THREE.MeshPhongMaterial({
                    color: COLORS.yellow,
                    emissive: COLORS.yellow,
                    emissiveIntensity: 0.3
                });
                const bar = new THREE.Mesh(barGeometry, barMaterial);
                bar.position.set(0, y, 0);
                bar.rotation.z = Math.PI / 2;
                bar.rotation.y = t;
                helixGroup.add(bar);
            }
        }
        
        // Create helix strands
        const curve1 = new THREE.CatmullRomCurve3(helixPoints);
        const tubeGeometry1 = new THREE.TubeGeometry(curve1, 100, 0.2, 8, false);
        const tubeMaterial1 = new THREE.MeshPhongMaterial({
            color: COLORS.cyan,
            emissive: COLORS.cyan,
            emissiveIntensity: 0.5
        });
        const tube1 = new THREE.Mesh(tubeGeometry1, tubeMaterial1);
        helixGroup.add(tube1);
        
        // Second strand (offset)
        const helixPoints2 = helixPoints.map(p => {
            const t = Math.atan2(p.z, p.x) + Math.PI;
            return new THREE.Vector3(
                Math.cos(t) * 10,
                p.y,
                Math.sin(t) * 10
            );
        });
        const curve2 = new THREE.CatmullRomCurve3(helixPoints2);
        const tubeGeometry2 = new THREE.TubeGeometry(curve2, 100, 0.2, 8, false);
        const tubeMaterial2 = new THREE.MeshPhongMaterial({
            color: COLORS.magenta,
            emissive: COLORS.magenta,
            emissiveIntensity: 0.5
        });
        const tube2 = new THREE.Mesh(tubeGeometry2, tubeMaterial2);
        helixGroup.add(tube2);
        
        scene.add(helixGroup);
        
        // FLOATING LETTERS - "HYPERACTIV"
        const letterWord = 'HYPERACTIV';
        const letterMeshes = [];
        const loader = new THREE.FontLoader();
        
        // Create letter geometries using simple box shapes (since we can't load external fonts)
        letterWord.split('').forEach((letter, index) => {
            const letterGroup = new THREE.Group();
            
            // Create letter using line segments for neon effect
            const material = new THREE.LineBasicMaterial({
                color: letterColors[letter.toLowerCase()] || COLORS.cyan,
                linewidth: 2
            });
            
            // Simple box representation of letters
            const boxGeometry = new THREE.BoxGeometry(1.5, 2, 0.5);
            const boxMaterial = new THREE.MeshPhongMaterial({
                color: letterColors[letter.toLowerCase()] || COLORS.cyan,
                emissive: letterColors[letter.toLowerCase()] || COLORS.cyan,
                emissiveIntensity: 0.7,
                transparent: true,
                opacity: 0.8
            });
            const letterMesh = new THREE.Mesh(boxGeometry, boxMaterial);
            
            // Position letters in a circle around the scene
            const angle = (index / letterWord.length) * Math.PI * 2;
            const radius = 15;
            letterMesh.position.x = Math.cos(angle) * radius;
            letterMesh.position.z = Math.sin(angle) * radius;
            letterMesh.position.y = Math.sin(index) * 3;
            
            letterMesh.userData = { 
                letter: letter, 
                originalY: letterMesh.position.y,
                phase: index * 0.5 
            };
            
            letterMeshes.push(letterMesh);
            scene.add(letterMesh);
        });
        
        // FRACTAL PYRAMIDS
        function createFractalPyramid(level, size, position) {
            if (level === 0) return;
            
            const geometry = new THREE.TetrahedronGeometry(size);
            const material = new THREE.MeshPhongMaterial({
                color: Object.values(COLORS)[level % 8],
                wireframe: true,
                emissive: Object.values(COLORS)[level % 8],
                emissiveIntensity: 0.3
            });
            const pyramid = new THREE.Mesh(geometry, material);
            pyramid.position.copy(position);
            scene.add(pyramid);
            
            if (level > 1) {
                const newSize = size * 0.5;
                const offset = size * 0.5;
                createFractalPyramid(level - 1, newSize, position.clone().add(new THREE.Vector3(offset, 0, 0)));
                createFractalPyramid(level - 1, newSize, position.clone().add(new THREE.Vector3(-offset, 0, 0)));
                createFractalPyramid(level - 1, newSize, position.clone().add(new THREE.Vector3(0, offset, 0)));
            }
        }
        
        // Create fractal pyramids
        createFractalPyramid(4, 3, new THREE.Vector3(-20, 0, -10));
        createFractalPyramid(4, 3, new THREE.Vector3(20, 0, -10));
        
        // PARTICLE SYSTEM - Natural Numbers
        const particleCount = 1729; // Ramanujan's number!
        const particles = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        
        for (let i = 0; i < particleCount; i++) {
            positions.push(
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100
            );
            
            const color = new THREE.Color(Object.values(COLORS)[i % 8]);
            colors.push(color.r, color.g, color.b);
        }
        
        particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        
        // Mouse interaction
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        
        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });
        
        // Click to explode
        let exploding = false;
        document.addEventListener('click', () => {
            exploding = true;
            setTimeout(() => { exploding = false; }, 2000);
        });
        
        // Space to morph
        let morphing = false;
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                morphing = !morphing;
                event.preventDefault();
            }
        });
        
        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Rotate main tetrahedron
            tetrahedron.rotation.x += 0.005;
            tetrahedron.rotation.y += 0.007;
            
            // Pulse core
            core.scale.setScalar(1 + Math.sin(time * 2) * 0.2);
            
            // Rotate DNA helix
            helixGroup.rotation.y += 0.003;
            
            // Animate letters
            letterMeshes.forEach((letter, index) => {
                const userData = letter.userData;
                letter.position.y = userData.originalY + Math.sin(time + userData.phase) * 2;
                letter.rotation.x = Math.sin(time + index) * 0.1;
                letter.rotation.y = time + index * 0.1;
                
                if (exploding) {
                    letter.position.x *= 1.02;
                    letter.position.z *= 1.02;
                    letter.rotation.x += 0.1;
                    letter.rotation.z += 0.1;
                } else {
                    const angle = (index / letterMeshes.length) * Math.PI * 2 + time * 0.1;
                    const radius = 15 + Math.sin(time + index) * 2;
                    letter.position.x = Math.cos(angle) * radius;
                    letter.position.z = Math.sin(angle) * radius;
                }
            });
            
            // Particle animation
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += Math.sin(time + i) * 0.01;
                
                if (morphing) {
                    positions[i] += Math.cos(time + i) * 0.1;
                    positions[i + 2] += Math.sin(time + i) * 0.1;
                }
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.rotation.y += 0.001;
            
            // Light animation
            pointLight1.position.x = Math.sin(time) * 30;
            pointLight1.position.z = Math.cos(time) * 30;
            pointLight2.position.x = Math.cos(time) * 30;
            pointLight2.position.z = Math.sin(time) * 30;
            
            // Camera movement based on mouse
            camera.position.x += (mouse.x * 10 - camera.position.x) * 0.05;
            camera.position.y += (-mouse.y * 10 - camera.position.y) * 0.05;
            camera.lookAt(scene.position);
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Add scrolling for zoom
        document.addEventListener('wheel', (event) => {
            camera.position.z += event.deltaY * 0.01;
            camera.position.z = Math.max(5, Math.min(50, camera.position.z));
        });
    </script>
</body>
</html>