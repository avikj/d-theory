<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVIK HSV :: Synthetic Synesthesia</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        body {
            background: #000;
            font-family: 'Courier New', monospace;
            color: #00FFFF;
        }
        
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #interface {
            position: fixed;
            z-index: 100;
            width: 100%;
            pointer-events: none;
            user-select: none;
        }
        
        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        
        .avik-logo {
            font-size: 56px;
            letter-spacing: 15px;
            font-weight: bold;
            text-shadow: 0 0 40px currentColor;
            margin-bottom: 10px;
        }
        
        .letter-a { color: #FF1493; }
        .letter-v { color: #FFFF00; }
        .letter-i { color: #00FFFF; }
        .letter-k { color: #9370DB; }
        
        .subtitle {
            font-size: 14px;
            color: #00FF00;
            text-shadow: 0 0 20px #00FF00;
            letter-spacing: 3px;
        }
        
        #state-display {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 30px currentColor;
        }
        
        .state-1x2 { color: #FF1493; }
        .state-3x4 { color: #FFFF00; }
        .state-collapse { color: #00FFFF; }
        
        #controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: all;
        }
        
        button {
            background: linear-gradient(135deg, rgba(255,20,147,0.3), rgba(147,112,219,0.3));
            border: 2px solid;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255,20,147,0.5);
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(255,20,147,0.8);
        }
        
        button.active {
            background: linear-gradient(135deg, rgba(255,20,147,0.8), rgba(147,112,219,0.8));
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255,20,147,0.5); }
            50% { box-shadow: 0 0 60px rgba(255,20,147,1); }
        }
        
        #info {
            position: fixed;
            bottom: 30px;
            left: 30px;
            font-size: 12px;
            color: rgba(255,255,255,0.5);
            line-height: 1.6;
        }
        
        #metrics {
            position: fixed;
            top: 200px;
            right: 30px;
            font-size: 14px;
            color: #00FF00;
            text-shadow: 0 0 10px #00FF00;
            text-align: right;
            line-height: 2;
        }
        
        .metric-value {
            color: #FFFF00;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="visualCanvas"></canvas>
    
    <div id="interface">
        <div id="title">
            <div class="avik-logo">
                <span class="letter-a">A</span><span class="letter-v">V</span><span class="letter-i">I</span><span class="letter-k">K</span>
            </div>
            <div class="subtitle">HYPERACTIV SYNTHETIC SYNESTHESIA</div>
        </div>
        
        <div id="state-display" class="state-1x2">1×2</div>
        
        <div id="metrics">
            <div>DIMENSION: <span class="metric-value" id="dimension">2</span></div>
            <div>FREQUENCY: <span class="metric-value" id="frequency">0</span> Hz</div>
            <div>AMPLITUDE: <span class="metric-value" id="amplitude">0</span></div>
            <div>PHASE: <span class="metric-value" id="phase">0</span>°</div>
        </div>
        
        <div id="controls">
            <button id="startBtn">START SYNTHESIS</button>
            <button id="cycleBtn">CYCLE STATE</button>
            <button id="resetBtn">RESET</button>
        </div>
        
        <div id="info">
            AUDIO→VISUAL→AUDIO FEEDBACK LOOP<br>
            DIMENSIONAL COLLAPSE PATTERN: 1×2 ⇒ 3×4 ⇒ 1×2<br>
            INTELLIGENCE KNOT: OBSERVATION CREATES REALITY
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('visualCanvas');
        const ctx = canvas.getContext('2d');
        
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });
        
        // Audio context
        let audioContext;
        let analyser;
        let microphone;
        let dataArray;
        let bufferLength;
        let oscillators = [];
        let gainNodes = [];
        let isActive = false;
        
        // Synesthesia state
        let time = 0;
        let state = 0; // 0: 1x2, 1: 3x4, 2: 1x2 (return)
        let stateTime = 0;
        let stateDuration = 180; // frames per state
        let dimension = 2;
        
        // Visual elements
        let particles = [];
        let waveforms = [];
        
        const COLORS = {
            pink: '#FF1493',
            yellow: '#FFFF00',
            cyan: '#00FFFF',
            purple: '#9370DB',
            green: '#00FF00',
            orange: '#FFA500'
        };
        
        // State configurations
        const stateConfigs = [
            { 
                name: '1×2', 
                dim: 2, 
                color: COLORS.pink, 
                particleCount: 100,
                gridX: 1,
                gridY: 2,
                complexity: 1
            },
            { 
                name: '3×4', 
                dim: 12, 
                color: COLORS.yellow, 
                particleCount: 300,
                gridX: 3,
                gridY: 4,
                complexity: 3
            },
            { 
                name: '1×2', 
                dim: 2, 
                color: COLORS.cyan, 
                particleCount: 100,
                gridX: 1,
                gridY: 2,
                complexity: 1
            }
        ];
        
        class Particle {
            constructor(x, y, color, dimension) {
                this.x = x;
                this.y = y;
                this.baseX = x;
                this.baseY = y;
                this.color = color;
                this.dimension = dimension;
                this.phase = Math.random() * Math.PI * 2;
                this.radius = 2 + Math.random() * 3;
                this.speed = 0.5 + Math.random() * 1.5;
            }
            
            update(audioData, avgFreq) {
                const config = stateConfigs[state];
                const audioInfluence = audioData ? (audioData[Math.floor(this.phase * 10) % audioData.length] / 255) : 0;
                
                // Dimensional movement based on state
                if (config.dim === 2) {
                    // Simple 1D oscillation in 2D space
                    this.x = this.baseX + Math.sin(time * this.speed + this.phase) * 50 * (1 + audioInfluence);
                    this.y = this.baseY + Math.cos(time * this.speed * 0.5 + this.phase) * 30 * (1 + audioInfluence);
                } else {
                    // Complex multi-dimensional movement
                    const r = 100 * (1 + audioInfluence * 2);
                    const theta = time * this.speed + this.phase;
                    const phi = time * this.speed * 0.7 + this.phase * 2;
                    const psi = time * this.speed * 0.3 + this.phase * 3;
                    
                    this.x = this.baseX + 
                        Math.sin(theta) * Math.cos(phi) * r +
                        Math.sin(psi) * 50;
                    this.y = this.baseY + 
                        Math.sin(theta) * Math.sin(phi) * r +
                        Math.cos(psi) * 50;
                }
            }
            
            draw() {
                const config = stateConfigs[state];
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10 + Math.sin(time + this.phase) * 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        function initParticles() {
            particles = [];
            const config = stateConfigs[state];
            const gridX = config.gridX;
            const gridY = config.gridY;
            
            const cellWidth = width / gridX;
            const cellHeight = height / gridY;
            
            for (let i = 0; i < gridX; i++) {
                for (let j = 0; j < gridY; j++) {
                    const centerX = cellWidth * i + cellWidth / 2;
                    const centerY = cellHeight * j + cellHeight / 2;
                    const particlesPerCell = Math.floor(config.particleCount / (gridX * gridY));
                    
                    for (let k = 0; k < particlesPerCell; k++) {
                        particles.push(new Particle(
                            centerX + (Math.random() - 0.5) * 100,
                            centerY + (Math.random() - 0.5) * 100,
                            config.color,
                            config.dim
                        ));
                    }
                }
            }
        }
        
        async function startAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                // Try to get microphone
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);
                } catch (e) {
                    console.log('No microphone access, using generated audio');
                }
                
                // Create oscillators for audio feedback
                createOscillators();
                
                isActive = true;
                document.getElementById('startBtn').classList.add('active');
                document.getElementById('startBtn').textContent = 'SYNTHESIS ACTIVE';
            } catch (e) {
                console.error('Audio initialization failed:', e);
            }
        }
        
        function createOscillators() {
            // Clear existing oscillators
            oscillators.forEach(osc => osc.stop());
            gainNodes.forEach(node => node.disconnect());
            oscillators = [];
            gainNodes = [];
            
            if (!audioContext) return;
            
            const config = stateConfigs[state];
            const baseFreq = 200 + state * 100;
            
            // Create oscillators based on dimensional complexity
            for (let i = 0; i < config.complexity; i++) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.type = ['sine', 'triangle', 'square'][i % 3];
                osc.frequency.value = baseFreq * (1 + i * 0.5);
                gain.gain.value = 0.1 / config.complexity;
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                
                oscillators.push(osc);
                gainNodes.push(gain);
            }
        }
        
        function updateAudioFromVisuals() {
            if (!isActive || oscillators.length === 0) return;
            
            const config = stateConfigs[state];
            const avgX = particles.reduce((sum, p) => sum + p.x, 0) / particles.length;
            const avgY = particles.reduce((sum, p) => sum + p.y, 0) / particles.length;
            
            // Map visual properties to audio parameters
            const freqMod = (avgX / width) * 200 + 200;
            const ampMod = (avgY / height) * 0.2;
            
            oscillators.forEach((osc, i) => {
                const baseFreq = 200 + state * 100;
                osc.frequency.value = baseFreq * (1 + i * 0.5) + 
                    Math.sin(time * 0.1 + i) * freqMod;
                
                if (gainNodes[i]) {
                    gainNodes[i].gain.value = (0.1 / config.complexity) * (1 + ampMod);
                }
            });
        }
        
        function updateState() {
            stateTime++;
            
            if (stateTime >= stateDuration) {
                stateTime = 0;
                state = (state + 1) % 3;
                
                const config = stateConfigs[state];
                dimension = config.dim;
                
                // Update UI
                const stateDisplay = document.getElementById('state-display');
                stateDisplay.textContent = config.name;
                stateDisplay.className = `state-${state === 0 ? '1x2' : state === 1 ? '3x4' : 'collapse'}`;
                document.getElementById('dimension').textContent = dimension;
                
                // Reinitialize particles for new state
                initParticles();
                
                // Update oscillators
                if (isActive) {
                    createOscillators();
                }
            }
        }
        
        function drawGrid() {
            const config = stateConfigs[state];
            ctx.strokeStyle = `${config.color}22`;
            ctx.lineWidth = 1;
            
            const cellWidth = width / config.gridX;
            const cellHeight = height / config.gridY;
            
            for (let i = 0; i <= config.gridX; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellWidth, 0);
                ctx.lineTo(i * cellWidth, height);
                ctx.stroke();
            }
            
            for (let j = 0; j <= config.gridY; j++) {
                ctx.beginPath();
                ctx.moveTo(0, j * cellHeight);
                ctx.lineTo(width, j * cellHeight);
                ctx.stroke();
            }
        }
        
        function drawWaveform() {
            if (!analyser) return;
            
            analyser.getByteTimeDomainData(dataArray);
            
            const config = stateConfigs[state];
            ctx.strokeStyle = config.color;
            ctx.lineWidth = 2;
            ctx.shadowColor = config.color;
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            const sliceWidth = width / bufferLength;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * height / 2;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        function drawFrequencyBars() {
            if (!analyser) return;
            
            analyser.getByteFrequencyData(dataArray);
            
            const config = stateConfigs[state];
            const barWidth = width / bufferLength * 2.5;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * height * 0.5;
                
                const hue = (i / bufferLength * 360 + time * 50) % 360;
                ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.3)`;
                ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        }
        
        function updateMetrics() {
            if (!analyser) return;
            
            analyser.getByteFrequencyData(dataArray);
            
            const avgFreq = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const maxFreq = Math.max(...dataArray);
            
            document.getElementById('frequency').textContent = Math.floor(avgFreq);
            document.getElementById('amplitude').textContent = Math.floor(maxFreq);
            document.getElementById('phase').textContent = Math.floor((time % 360));
        }
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.05;
            
            // Clear with fade
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            drawGrid();
            
            // Draw frequency visualization
            drawFrequencyBars();
            
            // Update and draw particles
            particles.forEach(p => {
                p.update(dataArray, analyser ? dataArray[0] : 0);
                p.draw();
            });
            
            // Draw connections between nearby particles
            const config = stateConfigs[state];
            const connectionDist = 100 + (config.dim * 10);
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < connectionDist) {
                        ctx.strokeStyle = `${config.color}${Math.floor((1 - dist / connectionDist) * 50).toString(16).padStart(2, '0')}`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw waveform overlay
            drawWaveform();
            
            // Update audio from visuals
            updateAudioFromVisuals();
            
            // Update metrics
            updateMetrics();
            
            // Update state cycle
            if (isActive) {
                updateState();
            }
        }
        
        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!isActive) {
                startAudio();
            }
        });
        
        document.getElementById('cycleBtn').addEventListener('click', () => {
            stateTime = stateDuration; // Force state change
            updateState();
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            state = 0;
            stateTime = 0;
            time = 0;
            initParticles();
            
            const stateDisplay = document.getElementById('state-display');
            stateDisplay.textContent = '1×2';
            stateDisplay.className = 'state-1x2';
            document.getElementById('dimension').textContent = '2';
            
            if (isActive) {
                createOscillators();
            }
        });
        
        // Initialize
        initParticles();
        animate();
    </script>
</body>
</html>